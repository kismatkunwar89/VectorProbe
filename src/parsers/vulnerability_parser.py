
"""
vulnerability_parser.py

Responsible for:
- Parsing the JSON output from: searchsploit --json <query>
- Normalizing it into a consistent list of exploit dictionaries
- Filtering exploits by version relevance (probable vulnerabilities only)

Why normalize?
- searchsploit output keys vary a bit depending on version/platform
- report_generator should not care about format differences
- We filter out noisy/irrelevant results to show only probable matches
"""

from __future__ import annotations

import re
from typing import Any, Dict, List, Optional

STOP_WORDS = {
    'service', 'server', 'client', 'default', 'unknown', 'open', 'port',
    'protocol', 'tcp', 'udp', 'http', 'https', 'ssl', 'tls'
}


def _extract_version_from_query(query: str) -> Optional[str]:
    """Extract version string from query (e.g., 'OpenSSH 7.4' -> '7.4')."""
    # Match patterns like "7.4", "7.4.1", "2.0.6"
    match = re.search(r'(\d+\.\d+(?:\.\d+)?)', query)
    return match.group(1) if match else None


def _extract_major_minor(version: str) -> Optional[str]:
    """Extract major.minor from version (e.g., '7.4.1' -> '7')."""
    match = re.match(r'(\d+)', version)
    return match.group(1) if match else None


def _version_matches(exploit_title: str, detected_version: Optional[str]) -> bool:
    """
    Check if exploit title mentions the detected version.

    Examples:
    - "OpenSSH 7.x - ..." matches "7.4"
    - "OpenSSH < 7.7 - ..." matches "7.4"
    - "OpenSSH 6.x - ..." does NOT match "7.4"
    """
    if not detected_version:
        return True  # No version filter, accept all

    major = _extract_major_minor(detected_version)
    if not major:
        return True

    title_lower = exploit_title.lower()

    # Patterns to match:
    # "7.x", "7.0 - 7.9", "OpenSSH 7", "< 7.7", "> 7.0", etc.
    patterns = [
        rf'\b{major}\.\d+',  # "7.4", "7.0", etc.
        rf'\b{major}\.x\b',  # "7.x"
        rf'< \d+\.{major}',   # "< 7.7"
        rf'> \d+\.{major}',   # "> 7.0"
        rf'{major}\.\d+ -',   # "7.4 -"
    ]

    for pattern in patterns:
        if re.search(pattern, title_lower):
            return True

    # Also check for explicit version tokens that match the same major
    precise_tokens = re.findall(r'\d+(?:\.\d+)+', title_lower)
    if not precise_tokens:
        return True

    for token in precise_tokens:
        if token.startswith(f"{major}."):
            return True

    return False


def _normalize_item(item: Dict[str, Any]) -> Dict[str, Any]:
    """
    Normalize an exploit record into consistent keys.

    We support common keys seen in searchsploit JSON output:
    - Title / EDB-ID / Date / Author / Type / Platform / Path / URL
    """
    return {
        "title": item.get("Title") or item.get("title") or "",
        "edb_id": item.get("EDB-ID") or item.get("edb_id") or item.get("id") or "",
        "date": item.get("Date") or item.get("date") or "",
        "author": item.get("Author") or item.get("author") or "",
        "type": item.get("Type") or item.get("type") or "",
        "platform": item.get("Platform") or item.get("platform") or "",
        "path": item.get("Path") or item.get("path") or "",
        "url": item.get("URL") or item.get("url") or "",
    }


def extract_search_keywords(query: str) -> List[str]:
    """Derive meaningful keywords from a service fingerprint for filtering."""
    if not query:
        return []

    tokens = re.findall(r'[A-Za-z0-9._-]+', query)
    keywords: List[str] = []
    seen = set()

    for token in tokens:
        lowered = token.lower()
        if lowered in seen:
            continue
        if lowered.isdigit():
            continue
        if len(lowered) < 4:
            continue
        if lowered in STOP_WORDS:
            continue
        keywords.append(lowered)
        seen.add(lowered)

    return keywords


def parse_searchsploit_json(
    raw_json: Dict[str, Any],
    query: Optional[str] = None,
    keywords: Optional[List[str]] = None
) -> List[Dict[str, Any]]:
    """
    Parse searchsploit JSON output into a flat list of normalized exploits.
    Filters by version relevance if version detected in query.

    Common formats include:
    A) {"RESULTS_EXPLOIT":[{...}], "RESULTS_SHELLCODE":[...]}
    B) {"results":{"exploit":[...], "shellcode":[...]}}
    C) {"EXPLOITS":[...]}  (varies)

    Args:
        raw_json: Parsed JSON from searchsploit --json
        query: Original search query (e.g., "OpenSSH 7.4")

    Args:
        raw_json: Parsed JSON from searchsploit --json
        query: Original search query (e.g., "OpenSSH 7.4")
        keywords: Optional precomputed keywords for better filtering

    Returns:
        A list of dicts like:
        [
          {"title": "...", "edb_id": "...", "path": "...", "url": "...", ...},
          ...
        ]
        Filtered to show only probable/relevant vulnerabilities.
    """
    if not raw_json:
        return []

    items: List[Dict[str, Any]] = []

    # --- Format A ---
    if isinstance(raw_json.get("RESULTS_EXPLOIT"), list):
        items.extend(raw_json["RESULTS_EXPLOIT"])

    if isinstance(raw_json.get("RESULTS_SHELLCODE"), list):
        items.extend(raw_json["RESULTS_SHELLCODE"])

    # --- Format B ---
    results = raw_json.get("results")
    if isinstance(results, dict):
        for key in ("exploit", "exploits", "shellcode"):
            arr = results.get(key)
            if isinstance(arr, list):
                items.extend(arr)

    # --- Format C ---
    for key in ("EXPLOITS", "exploits"):
        arr = raw_json.get(key)
        if isinstance(arr, list):
            items.extend(arr)

    # Normalize all dict items
    normalized: List[Dict[str, Any]] = []
    for item in items:
        if isinstance(item, dict):
            normalized.append(_normalize_item(item))

    # Extract version + keywords from query if provided
    detected_version = _extract_version_from_query(query) if query else None
    if keywords is None and query:
        keywords = extract_search_keywords(query)

    # Filter by version relevance and deduplicate
    seen = set()
    relevant: List[Dict[str, Any]] = []
    for e in normalized:
        title = e.get("title", "")
        key = (title, e.get("path", ""), e.get("edb_id", ""))

        # Skip if already seen
        if key in seen:
            continue

        # Skip if version doesn't match (only probable vulns)
        if not _version_matches(title, detected_version):
            continue

        if keywords:
            title_lower = title.lower()
            path_lower = (e.get("path", "") or "").lower()
            if not any(kw in title_lower or kw in path_lower for kw in keywords):
                continue

        seen.add(key)
        relevant.append(e)

    return relevant
